import { XRay } from "@/xRay"
import { searchMoviesByThemes } from "./fakeMovies"
import { llmEvaluateMovieRelevance } from "./fakeMovieLLM"

export async function runMovieRecommendation() {
  const xray = new XRay("movie-exec-" + crypto.randomUUID(), {
    domain: "movie-recommendation"
  })

  const referenceMovie = "Inception"

  // STEP 1: Understand preferences
  xray.startStep("preference_understanding", {
    seed_movie: referenceMovie,
    user_likes: ["Sci-Fi", "Thriller"]
  })

  const themes = ["time manipulation", "mind-bending"]
  await xray.endStep("preference_understanding", {  // ✅ await
    extracted_themes: themes
    // reasoning auto-generated by XRay! ✨
  })

  // STEP 2: Candidate search
  xray.startStep("candidate_search", {
    themes,
    limit: 50
  })

  const searchResult = searchMoviesByThemes(themes)
  await xray.endStep("candidate_search", {  // ✅ await
    total_found: searchResult.total_found,
    candidates_fetched: searchResult.candidates.length,
    candidates: searchResult.candidates
    // reasoning auto-generated by XRay! ✨
  })

  // STEP 2.5: Exclude reference movie
  xray.startStep("exclude_reference_item", {
    reference_movie: referenceMovie,
    initial_candidates: searchResult.candidates.length
  })

  const candidatesWithoutSeed = searchResult.candidates.filter(
    m => m.title !== referenceMovie
  )

  await xray.endStep("exclude_reference_item", {  // ✅ await
    removed: searchResult.candidates
      .filter(m => m.title === referenceMovie)
      .map(m => m.title),
    remaining_candidates: candidatesWithoutSeed.length,
    remaining: candidatesWithoutSeed
    // reasoning auto-generated by XRay! ✨
  })

// STEP 3: Apply filters
xray.startStep("apply_filters", {
  candidates_count: candidatesWithoutSeed.length,  // ✅ ADD THIS
  min_rating: 7.5,
  max_age_years: 15
})

const currentYear = new Date().getFullYear()
const filtered = candidatesWithoutSeed.filter(
  m =>
    m.rating >= 7.5 &&
    currentYear - m.year <= 15
)

await xray.endStep("apply_filters", {
  total_evaluated: candidatesWithoutSeed.length,  // ✅ ADD THIS
  passed: filtered.length,
  failed: candidatesWithoutSeed.length - filtered.length,
  remaining: filtered
  // Now gets: "Applied min_rating, max_age_years → 2/5 passed"
})


  // STEP 4: LLM relevance evaluation
  xray.startStep("llm_relevance_evaluation", {
    candidates_count: filtered.length,
    reference_movie: {
      title: referenceMovie,
      themes,
    },
    model: "fake-gpt-4"
  })

  const llmResults = llmEvaluateMovieRelevance(referenceMovie, filtered)
  const confirmedRelevant = llmResults.filter(r => r.isRelevant)
  const rejected = llmResults.filter(r => !r.isRelevant)

  await xray.endStep("llm_relevance_evaluation", {  // ✅ await
    total_evaluated: llmResults.length,
    confirmed_relevant: confirmedRelevant.length,
    rejected_as_irrelevant: rejected.length,
    evaluations: llmResults.map(r => ({
      id: r.movie.id,
      title: r.movie.title,
      is_relevant: r.isRelevant,
      confidence: r.confidence,
      rejection_reason: r.rejection_reason
        ? {
            code: r.rejection_reason.code,
            explanation: r.rejection_reason.explanation
          }
        : undefined
    }))
    // reasoning auto-generated by XRay! ✨
  })

  // STEP 5: Rank & select
  xray.startStep("rank_and_select", {
    ranking: ["rating", "recency"]
  })

  const ranked = confirmedRelevant
    .sort((a, b) => b.movie.rating - a.movie.rating)
    .map((r, i) => ({
      rank: i + 1,
      movie: r.movie,
      confidence: r.confidence
    }))

  const selected = ranked[0]

  await xray.endStep("rank_and_select", {  // ✅ await
    ranked_candidates: ranked,
    selection: selected
    // reasoning auto-generated by XRay! ✨
  })

  return xray.end({
    decision: selected ? "MOVIE_RECOMMENDED" : "NO_RECOMMENDATION",
    movie: selected?.movie
  })
}
